<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMR Scanner - Review & Confirm</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    
    <style>
        :root { --primary: #2563eb; --bg: #f8fafc; --panel: #ffffff; --border: #e2e8f0; }
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: var(--bg); margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; }
        
        header { background: white; padding: 12px 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05); z-index: 10; }
        h1 { margin: 0; font-size: 1.1rem; color: #1e293b; font-weight: 600; }
        #status { font-size: 0.9rem; color: var(--primary); font-weight: 500; }

        .main-layout { display: flex; flex: 1; overflow: hidden; }

        /* Sidebar */
        .sidebar { width: 320px; background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow-y: auto; padding: 20px; flex-shrink: 0; }
        
        .control-section { margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 15px; }
        .control-section h3 { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px; color: #64748b; margin: 0 0 12px 0; font-weight: 700; }
        
        .slider-group { margin-bottom: 10px; }
        .slider-group label { display: flex; justify-content: space-between; font-size: 0.85rem; font-weight: 600; color: #334155; margin-bottom: 4px; }
        .slider-group input[type="range"] { width: 100%; accent-color: var(--primary); }
        .number-input { width: 100%; padding: 8px; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box; }
        
        .btn { background: var(--primary); color: white; border: none; padding: 10px; width: 100%; border-radius: 6px; cursor: pointer; font-weight: 600; margin-top: 8px; transition: background 0.2s; font-size: 0.9rem; }
        .btn:hover { background: #1d4ed8; }
        .btn:disabled { background: #cbd5e1; cursor: not-allowed; }
        .btn.secondary { background: #64748b; }
        .btn.secondary:hover { background: #475569; }
        .btn.warning { background: #f59e0b; color: #fff; }
        .btn.warning:hover { background: #d97706; }
        
        /* Workspace */
        .workspace { flex: 1; background: #cbd5e1; position: relative; display: flex; flex-direction: column; }
        
        .canvas-container { 
            flex: 1; 
            overflow: auto; 
            display: flex; 
            padding: 20px; 
            scroll-behavior: smooth; 
        }
        
        .canvas-wrapper { 
            position: relative; 
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1); 
            background: white; 
            margin: auto; 
            flex-shrink: 0; 
        }
        
        canvas { 
            display: block; 
            transform-origin: 0 0; 
        }

        /* Pagination Bar */
        .pagination-bar { 
            background: white; 
            padding: 10px 20px; 
            border-bottom: 1px solid var(--border); 
            display: flex; 
            justify-content: flex-start; 
            gap: 20px; 
            align-items: center; 
        }
        
        .control-divider { width: 1px; height: 24px; background: #e2e8f0; }

        .page-controls { display: flex; gap: 10px; align-items: center; }
        .zoom-controls { display: flex; gap: 5px; align-items: center; }
        
        .page-btn { padding: 5px 15px; background: #e2e8f0; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; color: #475569; }
        .page-btn:hover { background: #cbd5e1; }
        
        .zoom-btn { width: 30px; height: 30px; background: #e2e8f0; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; color: #475569; display: flex; align-items: center; justify-content: center; }
        .zoom-btn:hover { background: #cbd5e1; }

        /* Results Sidebar */
        .results-sidebar { width: 340px; background: var(--panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; }
        .results-header { padding: 12px; background: #f1f5f9; border-bottom: 1px solid var(--border); display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 5px; }
        .results-body { flex: 1; overflow-y: auto; scroll-behavior: smooth; }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.85rem; table-layout: fixed; }
        th { background: #f8fafc; padding: 8px; text-align: left; position: sticky; top: 0; border-bottom: 1px solid var(--border); color: #475569; font-weight: 600; z-index: 2; }
        td { padding: 8px; border-bottom: 1px solid var(--border); color: #334155; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: pointer; }
        tr:hover { background-color: #e0f2fe; }
        tr.selected-row { background-color: #bae6fd !important; border-left: 4px solid var(--primary); }

        .editable-cell { border: 1px dashed #cbd5e1; background: #fff; padding: 2px 5px; border-radius: 3px; text-align: center; font-weight: bold; }
        .editable-cell:focus { border-color: var(--primary); outline: none; background: #eff6ff; }

        .status-ok { color: #16a34a; }
        .status-multi { color: #f59e0b; background: #fffbeb; }
        .status-empty { color: #ef4444; background: #fef2f2; }
    </style>
</head>
<body>

<header>
    <h1>OMR Review Tool</h1>
    <div id="status">Waiting for file...</div>
</header>

<div class="main-layout">
    
    <!-- Controls -->
    <div class="sidebar">
        <div class="control-section">
            <h3>1. Configuration</h3>
            <input type="file" id="fileInput" accept=".pdf, .jpg, .png, .jpeg" style="margin-bottom:10px; width:100%">
            
            <div style="margin-top:10px;">
                <label style="font-size:0.85rem; font-weight:600; color:#334155">Questions per Page</label>
                <input type="number" id="qLimit" class="number-input" value="45" min="1" max="100">
            </div>
        </div>

        <div class="control-section">
            <h3>2. Grid Adjustments (Current Page)</h3>
            <div class="slider-group">
                <label>Start X <span></span></label> <input type="range" id="startX" min="0" max="1000" value="349">
            </div>
            <div class="slider-group">
                <label>Start Y <span></span></label> <input type="range" id="startY" min="0" max="1000" value="598">
            </div>
            <div class="slider-group">
                <label>Bubble Width <span></span></label> <input type="range" id="bubbleWidth" min="10" max="100" value="29">
            </div>
            <div class="slider-group">
                <label>Bubble Height <span></span></label> <input type="range" id="bubbleHeight" min="5" max="100" value="10">
            </div>
            <div class="slider-group">
                <label>Option Gap <span></span></label> <input type="range" id="gapOption" min="20" max="150" value="38">
            </div>
            <div class="slider-group">
                <label>Row Gap <span></span></label> <input type="range" id="gapRow" min="10" max="100" value="37">
            </div>
            <div class="slider-group">
                <label>Group/Col Gap <span></span></label> <input type="range" id="gapGroup" min="50" max="500" value="217">
            </div>
            <div class="slider-group">
                <label>Block Gap <span></span></label> <input type="range" id="gapBlock" min="0" max="100" value="23">
            </div>
        </div>

        <div class="control-section">
            <h3>3. Actions</h3>
            <div class="slider-group">
                <label>Darkness Threshold <span></span></label>
                <input type="range" id="threshold" min="50" max="230" value="213">
            </div>
            <button id="scanBtn" class="btn" onclick="startBatchScan()">Scan All Pages</button>
            <button id="reScanPageBtn" class="btn secondary" onclick="reScanCurrentPage()" disabled>Rescan Current Page</button>
        </div>
    </div>

    <!-- Workspace -->
    <div class="workspace">
        <div class="pagination-bar">
            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <span style="font-size:0.85rem; color:#64748b; margin-right:5px;">Zoom:</span>
                <button class="zoom-btn" onclick="changeZoom(-0.1)" title="Zoom Out">-</button>
                <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom">R</button>
                <button class="zoom-btn" onclick="changeZoom(0.1)" title="Zoom In">+</button>
                <span id="zoomLabel" style="font-size:0.85rem; color:#334155; width:40px; text-align:center;">100%</span>
            </div>

            <div class="control-divider"></div>

            <!-- Page Controls -->
            <div class="page-controls">
                <button class="page-btn" onclick="changePage(-1)">Previous</button>
                <span id="pageIndicator" style="font-weight:600; color:#334155; font-size:0.9rem;">Page - of -</span>
                <button class="page-btn" onclick="changePage(1)">Next</button>
            </div>
        </div>
        
        <div class="canvas-container" id="canvasContainer">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="mainCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- Results -->
    <div class="results-sidebar">
        <div class="results-header">
            <div style="display:flex; gap:5px;">
                <button class="btn warning" style="width:auto; margin:0; padding:6px 10px; font-size:0.8rem;" onclick="findPreviousIssue()">Prev Issue</button>
                <button class="btn warning" style="width:auto; margin:0; padding:6px 10px; font-size:0.8rem;" onclick="findNextIssue()">Next Issue</button>
            </div>
            <button class="btn success" style="width:auto; margin:0; padding:6px 10px; font-size:0.8rem; background:#16a34a; color:white;" onclick="downloadMatrixExcel()">Export CSV</button>
        </div>
        <div class="results-body" id="resultsBody">
            <table id="resultsTable">
                <thead>
                    <tr>
                        <th style="width:40px">Pg</th>
                        <th style="width:40px">Q#</th>
                        <th>Answer (Edit)</th>
                        <th style="width:50px">Conf</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const canvasWrapper = document.getElementById('canvasWrapper');
    
    // State
    let currentPdfDoc = null;
    let currentImage = null; 
    let isProcessing = false;
    let hasScanned = false;
    let currentFileName = "omr_scan"; // Stores the uploaded filename
    
    // Data
    let globalResults = []; 
    let currentPage = 1;
    let totalPages = 1;
    let activeReviewQ = null; 
    let currentZoom = 1.0;
    
    // Configuration Storage
    // pageConfigs[pageNumber] = { startX: 100, ... }
    let pageConfigs = {}; 

    // Default Config
    const defaults = {
        startX: 349, startY: 598,
        bubbleWidth: 29, bubbleHeight: 10,
        gapOption: 38, gapGroup: 217,
        gapRow: 37, gapBlock: 23,
        threshold: 213
    };
    // Current active config (bound to sliders)
    let config = { ...defaults };

    function init() {
        // Sliders
        document.querySelectorAll('input[type="range"]').forEach(input => {
            const labelSpan = input.previousElementSibling.querySelector('span');
            if(labelSpan) labelSpan.innerText = input.value;
            
            input.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                config[e.target.id] = val;
                if(labelSpan) labelSpan.innerText = val;
                
                // Update the specific config for this page immediately
                if (!pageConfigs[currentPage]) pageConfigs[currentPage] = {};
                pageConfigs[currentPage][e.target.id] = val;
                
                if(!isProcessing) drawOverlay();
            });
        });

        document.getElementById('fileInput').addEventListener('change', handleFile);
        
        // Initial Canvas Text
        canvas.width = 800; canvas.height = 1000;
        ctx.font = "20px sans-serif"; ctx.fillStyle = "#94a3b8"; ctx.textAlign = "center";
        ctx.fillText("Upload PDF to Start", 400, 500);
        applyZoom();
    }

    async function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;

        // Extract filename without extension for export later
        const nameParts = file.name.split('.');
        if (nameParts.length > 1) nameParts.pop();
        currentFileName = nameParts.join('.');

        currentPdfDoc = null; currentImage = null;
        globalResults = []; hasScanned = false;
        pageConfigs = {}; // Reset page configs
        document.querySelector('#resultsTable tbody').innerHTML = '';
        document.getElementById('status').innerText = "Loading...";
        document.getElementById('reScanPageBtn').disabled = true;
        
        resetZoom();

        if (file.type === 'application/pdf') {
            const fileReader = new FileReader();
            fileReader.onload = async function() {
                const typedarray = new Uint8Array(this.result);
                currentPdfDoc = await pdfjsLib.getDocument(typedarray).promise;
                totalPages = currentPdfDoc.numPages;
                currentPage = 1;
                // Initialize config for page 1
                pageConfigs[1] = { ...config };
                await viewPage(1);
                document.getElementById('status').innerText = "Ready. Adjust grid, then Scan.";
            };
            fileReader.readAsArrayBuffer(file);
        } else {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    totalPages = 1; currentPage = 1;
                    pageConfigs[1] = { ...config };
                    canvas.width = img.width; canvas.height = img.height;
                    checkDimensions(img.width, img.height);
                    drawOverlay();
                    updatePageIndicator();
                    applyZoom(); 
                    document.getElementById('status').innerText = "Ready to Scan Image";
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }
    }

    async function viewPage(pageNum) {
        if (!currentPdfDoc && !currentImage) return;
        
        // Load config for this page if it exists, otherwise inherit from current or defaults
        if (pageConfigs[pageNum]) {
            config = { ...pageConfigs[pageNum] };
        } else {
            // If visiting a new page without config, save current config as its starting point
            pageConfigs[pageNum] = { ...config };
        }
        updateSlidersFromConfig();

        if (currentPdfDoc) {
            const page = await currentPdfDoc.getPage(pageNum);
            const viewport = page.getViewport({scale: 2.0});
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            await page.render({canvasContext: ctx, viewport: viewport}).promise;
            
            const img = new Image();
            img.src = canvas.toDataURL();
            await new Promise(r => img.onload = r);
            currentImage = img;
            
            checkDimensions(viewport.width, viewport.height);
        } else {
            ctx.drawImage(currentImage, 0, 0);
        }

        updatePageIndicator();
        drawOverlay();
        applyZoom();
    }

    function updateSlidersFromConfig() {
        for (const key in config) {
            const el = document.getElementById(key);
            if (el) {
                el.value = config[key];
                const span = el.previousElementSibling.querySelector('span');
                if(span) span.innerText = config[key];
            }
        }
    }

    function changePage(delta) {
        const newPage = currentPage + delta;
        if (newPage >= 1 && newPage <= totalPages) {
            currentPage = newPage;
            viewPage(currentPage);
        }
    }

    function updatePageIndicator() {
        document.getElementById('pageIndicator').innerText = `Page ${currentPage} of ${totalPages}`;
    }

    // --- ZOOM FUNCTIONS ---
    function changeZoom(delta) {
        currentZoom = parseFloat((currentZoom + delta).toFixed(1));
        if(currentZoom < 0.2) currentZoom = 0.2;
        if(currentZoom > 3.0) currentZoom = 3.0;
        applyZoom();
    }

    function resetZoom() {
        currentZoom = 1.0;
        applyZoom();
    }

    function applyZoom() {
        canvas.style.transform = `scale(${currentZoom})`;
        document.getElementById('zoomLabel').innerText = Math.round(currentZoom * 100) + '%';
        
        if(canvas.width > 0 && canvas.height > 0) {
            canvasWrapper.style.width = `${canvas.width * currentZoom}px`;
            canvasWrapper.style.height = `${canvas.height * currentZoom}px`;
        }
    }

    function checkDimensions(w, h) {
        const maxDim = Math.max(w, h);
        if(maxDim > 1000) {
            document.getElementById('startX').max = w;
            document.getElementById('startY').max = h;
        }
    }

    // --- GEOMETRY ---
    // Accepts an optional config object to calculate rects based on specific page settings
    function getBubbleRect(qNum, optIndex, specificConfig = config) {
        const qIndex = qNum - 1; 
        const colGroup = Math.floor(qIndex / 25); 
        const localRowIndex = qIndex % 25; 
        const blockIndex = Math.floor(localRowIndex / 5); 
        
        const x = specificConfig.startX + (colGroup * specificConfig.gapGroup) + (optIndex * specificConfig.gapOption);
        const y = specificConfig.startY + (localRowIndex * specificConfig.gapRow) + (blockIndex * specificConfig.gapBlock);
        return { x, y, w: specificConfig.bubbleWidth, h: specificConfig.bubbleHeight };
    }

    function drawOverlay() {
        if (!currentImage) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(currentImage, 0, 0);
        
        const qLimit = parseInt(document.getElementById('qLimit').value) || 100;

        if (hasScanned) {
            drawScannedOverlay(qLimit);
        } else {
            drawSetupOverlay(qLimit);
        }
    }

    function drawSetupOverlay(limit) {
        ctx.lineWidth = 2;
        ctx.setLineDash([]); 
        for (let q = 1; q <= limit; q++) {
            for (let opt = 0; opt < 4; opt++) {
                const rect = getBubbleRect(q, opt);
                ctx.strokeStyle = 'rgba(220, 38, 38, 0.6)'; 
                ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                
                if (opt === 0 && (q % 5 === 1 || q === 1)) {
                    ctx.fillStyle = "#2563eb";
                    ctx.font = "bold 12px sans-serif";
                    ctx.fillText(q, rect.x - 20, rect.y + (rect.h/2) + 4);
                }
            }
        }
    }

    function drawScannedOverlay(limit) {
        const pageData = globalResults.filter(r => r.page === currentPage);
        
        pageData.forEach(row => {
            if (row.q > limit) return;

            // 1. Active Question Highlight
            if (activeReviewQ === row.q) {
                const startRect = getBubbleRect(row.q, 0);
                const endRect = getBubbleRect(row.q, 3);
                
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 4;

                // Dotted line for EMPTY
                if (row.a === 'EMPTY') {
                    ctx.setLineDash([8, 6]); 
                } else {
                    ctx.setLineDash([]); 
                }

                // Draw the bounding box
                ctx.strokeRect(startRect.x - 8, startRect.y - 8, (endRect.x + endRect.w - startRect.x) + 16, startRect.h + 16);
                
                ctx.setLineDash([]); // Reset

                // Draw the arrow
                ctx.fillStyle = '#2563eb';
                ctx.beginPath();
                ctx.moveTo(startRect.x - 30, startRect.y + (startRect.h/2));
                ctx.lineTo(startRect.x - 15, startRect.y + (startRect.h/2));
                ctx.lineTo(startRect.x - 20, startRect.y + (startRect.h/2) - 5);
                ctx.lineTo(startRect.x - 20, startRect.y + (startRect.h/2) + 5);
                ctx.fill();
            }

            // 2. General Status Overlays
            if (row.a === 'MULTIPLE') {
                // No orange rects
            } else if (row.a === 'EMPTY') {
                // No fill
            } else {
                const map = {'A':0, 'B':1, 'C':2, 'D':3};
                if (map[row.a] !== undefined) {
                    const r = getBubbleRect(row.q, map[row.a]);
                    ctx.fillStyle = 'rgba(22, 163, 74, 0.5)';
                    ctx.fillRect(r.x, r.y, r.w, r.h);
                }
            }
        });
    }

    // --- SCANNING ---
    async function startBatchScan() {
        if (!currentPdfDoc && !currentImage) return alert("Please upload a file.");
        
        isProcessing = true;
        hasScanned = false;
        document.getElementById('scanBtn').disabled = true;
        document.getElementById('reScanPageBtn').disabled = true;
        globalResults = [];
        document.querySelector('#resultsTable tbody').innerHTML = '';
        
        const qLimit = parseInt(document.getElementById('qLimit').value) || 100;

        // Save current config as the baseline for all pages initially
        for(let p=1; p<=totalPages; p++) {
            if(!pageConfigs[p]) pageConfigs[p] = { ...config };
        }

        if (currentPdfDoc) {
            for (let i = 1; i <= totalPages; i++) {
                document.getElementById('status').innerText = `Scanning Page ${i} of ${totalPages}...`;
                // When scanning, we load the page, which sets the 'config' variable to that page's config
                await viewPage(i); 
                // Pass the specific config for this page to the scanner
                const results = scanCanvas(i, qLimit, pageConfigs[i]);
                globalResults.push(...results);
                await new Promise(r => setTimeout(r, 20));
            }
        } else {
            const results = scanCanvas(1, qLimit, config);
            globalResults.push(...results);
        }

        hasScanned = true;
        isProcessing = false;
        document.getElementById('scanBtn').disabled = false;
        document.getElementById('reScanPageBtn').disabled = false;
        document.getElementById('status').innerText = "Scan Complete. Review results.";
        
        renderTable();
        currentPage = 1;
        viewPage(1);
    }

    function reScanCurrentPage() {
        if (!hasScanned) return;
        
        const qLimit = parseInt(document.getElementById('qLimit').value) || 100;
        
        // 1. Remove old results for this page
        globalResults = globalResults.filter(r => r.page !== currentPage);
        
        // 2. Scan with current settings
        const newResults = scanCanvas(currentPage, qLimit, config);
        
        // 3. Add new results and sort
        globalResults.push(...newResults);
        globalResults.sort((a, b) => (a.page - b.page) || (a.q - b.q));
        
        // 4. Update UI
        renderTable();
        drawOverlay();
        document.getElementById('status').innerText = `Page ${currentPage} Rescanned.`;
    }

    function scanCanvas(pageNumber, limit, specificConfig) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const pageResults = [];
        const options = ['A', 'B', 'C', 'D'];

        for (let q = 1; q <= limit; q++) {
            let markedIndices = [];
            let confidences = [];

            for (let opt = 0; opt < 4; opt++) {
                // Use the specific config for rect calculation
                const rect = getBubbleRect(q, opt, specificConfig);
                let totalBrightness = 0;
                let count = 0;

                for (let py = Math.floor(rect.y); py < rect.y + rect.h; py++) {
                    for (let px = Math.floor(rect.x); px < rect.x + rect.w; px++) {
                        if(px<0||py<0||px>=canvas.width||py>=canvas.height) continue;
                        const idx = (py * canvas.width + px) * 4;
                        totalBrightness += (data[idx] + data[idx+1] + data[idx+2]) / 3;
                        count++;
                    }
                }
                const avg = count > 0 ? totalBrightness / count : 255;
                
                // Use specific threshold
                if (avg < specificConfig.threshold) {
                    markedIndices.push(opt);
                    confidences.push(Math.floor((255 - avg)));
                }
            }

            let finalAnswer = "EMPTY";
            let finalConf = 0;

            if (markedIndices.length === 1) {
                finalAnswer = options[markedIndices[0]];
                finalConf = confidences[0];
            } else if (markedIndices.length > 1) {
                finalAnswer = "MULTIPLE";
                finalConf = Math.max(...confidences);
            }

            pageResults.push({ 
                id: `${pageNumber}-${q}`,
                page: pageNumber, 
                q: q, 
                a: finalAnswer, 
                conf: finalConf 
            });
        }
        return pageResults;
    }

    // --- REVIEW & TABLE ---
    function renderTable() {
        const tbody = document.querySelector('#resultsTable tbody');
        tbody.innerHTML = '';

        globalResults.forEach(row => {
            const tr = document.createElement('tr');
            tr.id = `row-${row.id}`;
            
            let cssClass = '';
            if(row.a === 'EMPTY') cssClass = 'status-empty';
            else if(row.a === 'MULTIPLE') cssClass = 'status-multi';
            else cssClass = 'status-ok';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = row.a;
            input.className = `editable-cell ${cssClass}`;
            input.style.width = '80%';
            
            input.onchange = (e) => {
                const newVal = e.target.value.toUpperCase().trim();
                const valid = ['A','B','C','D','EMPTY','MULTIPLE'];
                if(valid.includes(newVal)) {
                    row.a = newVal;
                    input.className = `editable-cell ${newVal === 'EMPTY' ? 'status-empty' : newVal === 'MULTIPLE' ? 'status-multi' : 'status-ok'}`;
                    drawOverlay(); 
                } else {
                    alert("Invalid input. Use A, B, C, D, EMPTY, or MULTIPLE");
                    e.target.value = row.a; 
                }
            };

            tr.onclick = (e) => {
                if(e.target !== input) {
                    jumpToQuestion(row.page, row.q);
                }
            };

            tr.innerHTML = `
                <td style="color:#64748b">${row.page}</td>
                <td>${row.q}</td>
                <td></td>
                <td style="color:#64748b; font-size:0.8em">${row.conf}%</td>
            `;
            tr.children[2].appendChild(input);
            tbody.appendChild(tr);
        });
    }

    async function jumpToQuestion(pageNum, qNum) {
        if (currentPage !== pageNum) {
            currentPage = pageNum;
            await viewPage(currentPage);
        }

        activeReviewQ = qNum;
        
        document.querySelectorAll('tr').forEach(r => r.classList.remove('selected-row'));
        const row = document.getElementById(`row-${pageNum}-${qNum}`);
        if(row) {
            row.classList.add('selected-row');
            row.scrollIntoView({behavior: "smooth", block: "center"});
        }

        drawOverlay();

        const rect = getBubbleRect(qNum, 0);
        const container = document.getElementById('canvasContainer');
        
        const scaledY = rect.y * currentZoom;
        const scaledH = rect.h * currentZoom;
        
        const scrollTop = scaledY - (container.clientHeight / 2) + (scaledH / 2);
        container.scrollTo({ top: scrollTop, behavior: 'smooth' });
    }

    function findNextIssue() {
        let startIndex = -1;
        if (activeReviewQ !== null) {
            startIndex = globalResults.findIndex(r => r.page === currentPage && r.q === activeReviewQ);
        }

        let nextIssue = globalResults.find((r, i) => i > startIndex && (r.a === 'EMPTY' || r.a === 'MULTIPLE'));
        
        if (!nextIssue) {
            nextIssue = globalResults.find(r => r.a === 'EMPTY' || r.a === 'MULTIPLE');
            if (nextIssue) {
                alert("You have reached the end of the list. Returning to the first issue.");
            }
        }

        if (nextIssue) {
            jumpToQuestion(nextIssue.page, nextIssue.q);
        } else {
            alert("No more issues found!");
        }
    }

    function findPreviousIssue() {
        let startIndex = -1;
        if (activeReviewQ !== null) {
            startIndex = globalResults.findIndex(r => r.page === currentPage && r.q === activeReviewQ);
        }

        if (startIndex === -1) {
            startIndex = globalResults.length;
        }

        let prevIssue = null;
        for (let i = startIndex - 1; i >= 0; i--) {
            if (globalResults[i].a === 'EMPTY' || globalResults[i].a === 'MULTIPLE') {
                prevIssue = globalResults[i];
                break;
            }
        }

        if (!prevIssue) {
            for (let i = globalResults.length - 1; i > startIndex; i--) {
                if (globalResults[i].a === 'EMPTY' || globalResults[i].a === 'MULTIPLE') {
                    prevIssue = globalResults[i];
                    break;
                }
            }
            if (prevIssue) {
                alert("You have reached the start of the list. Jumping to the last issue.");
            }
        }

        if (prevIssue) {
            jumpToQuestion(prevIssue.page, prevIssue.q);
        } else {
            alert("No issues found!");
        }
    }

    function downloadMatrixExcel() {
        if (globalResults.length === 0) return alert("No data to export");
        
        let csv = "Question";
        for(let p=1; p<=totalPages; p++) csv += `,Page ${p}`;
        csv += "\n";

        const qLimit = parseInt(document.getElementById('qLimit').value) || 100;

        for(let q=1; q<=qLimit; q++) {
            let line = `${q}`;
            for(let p=1; p<=totalPages; p++) {
                const r = globalResults.find(x => x.page === p && x.q === q);
                line += `,${r ? r.a : 'EMPTY'}`;
            }
            csv += line + "\n";
        }

        // Generate Timestamp YYYYMMDD_HHMMSS
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        const hh = String(now.getHours()).padStart(2, '0');
        const min = String(now.getMinutes()).padStart(2, '0');
        const ss = String(now.getSeconds()).padStart(2, '0');
        const timestamp = `${yyyy}${mm}${dd}_${hh}${min}${ss}`;

        const blob = new Blob([csv], {type: 'text/csv'});
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        // Set dynamic filename
        a.download = `${currentFileName}_result_${timestamp}.csv`;
        a.click();
    }

    init();
</script>

</body>
</html>
